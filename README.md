Основная структура
  1. Внутренний класс Node (Узел)

          java
          private class Node {
              public K key;    // Ключ (для сравнения и поиска)
              public V value;  // Значение (данные)
              public Node left, right; // Левый и правый потомки
          }

  Каждый узел хранит пару ключ-значение и ссылки на дочерние узлы.

  3. Основные поля

          java
          private int size;    // Количество элементов
          private Node root;   // Корневой узел дерева

Основные методы
  1. findNode(Object key) - поиск узла

    java
    Comparable<K> cKey = (Comparable<K>) key; // Предполагаем, что ключи сравниваемые
    
  Использует бинарный поиск: сравнивает ключ с текущим узлом
  
  Если ключ меньше - идет влево, если больше - вправо
    
  Время поиска: O(log n) в сбалансированном дереве

2. put(K key, V value) - добавление элемента
    Рекурсивный алгоритм:
    
    Если дерево пустое - создает корень
    
    Сравнивает ключ с текущим узлом
    
    Если ключ меньше - идет влево, если больше - вправо
    
    Находит место для вставки или обновляет существующее значение

3. get(Object key) - получение значения
  Просто вызывает findNode() и возвращает значение найденного узла

  Самый сложный метод: remove(Object key) - удаление
  Удаление имеет 3 случая:

Случай 1: Узел без детей (лист)

    java
    if(child.left == null && child.right == null) {
        // Просто удаляем ссылку у родителя
        parent.left = null или parent.right = null
    }

  Пример: Удаляем узел 20 (лист)

Случай 2: Узел с одним ребенком

    java
    if(child.left == null) { // Есть только правый ребенок
        // "Перекидываем" ребенка на место удаляемого узла
        parent.right = child.right
    }

  Пример: Удаляем узел 90 (имеет только левого ребенка 85)

Случай 3: Узел с двумя детьми (самый сложный)

    java
    Node preemnik = this.findSmallest(child.right); // Находим преемника
    removeHelper(preemnik.key);                     // Удаляем преемника
    child.key = preemnik.key;                       // Заменяем ключ
    child.value = preemnik.value;                   // Заменяем значение

  Преемник - наименьший элемент в правом поддереве (или наибольший в левом)

Пример: При удалении корня 100:

  Находим преемника: наименьший в правом поддереве (110) → это 110
  
  Заменяем корень на 110, удаляем оригинальный узел 110
  
  Вспомогательные методы
  findParent(Object key) - поиск родителя
  Нужен для удаления, чтобы знать, какую ссылку обновить.
  
  LER(Node node) - обход дерева (In-Order)
Left-Element-Right выводит элементы в отсортированном порядке:

  Рекурсивно обходит левое поддерево
  
  Выводит текущий элемент
  
  Рекурсивно обходит правое поддерево
  
  Пример работы
Исходное дерево:

    text
            100
           /   \
         80     130
        /  \    /  \
       50  90  110  170
      / \  /     \    \
    20  60 85    120  140

После удаления корня (100):

    text
            110
           /   \
         80     130
        /  \    /  \
       50  90  120  170
      / \  /         \
    20  60 85        140

Преемник 110 занял место корня, дерево сохранило структуру.

